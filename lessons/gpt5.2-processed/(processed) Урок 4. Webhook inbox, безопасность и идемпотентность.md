В прошлом уроке мы научились фиксировать события внутри лендинга, чтобы понимать, как пользователи проходят путь до отправки контактов. Но часто этого недостаточно.

Иногда важные события происходят **за пределами страницы**. Например: пользователь оплатил курс, подтвердил участие, получил статус в платёжной системе или CRM. Если мы хотим считать конверсию «лид → покупка», такие события тоже нужно уметь принимать и сохранять.

---

## Почему внешние события важны

Лендинг — это только один элемент в цепочке. Вокруг него обычно работают рекламные кабинеты, платёжные сервисы, CRM и другие инструменты, которые тоже «живут» событиями: клики, переходы, оплаты, подтверждения, статусы.

Чтобы получать такие события от внешних систем, используют технологию **webhook**.

Webhook — это входящий HTTP-запрос от внешней системы, который сообщает нам: «произошло событие».

---

## Что приходит в webhook-запросе

В webhook обычно есть две важные части: **контроль безопасности** и **данные события**.

В запросе к нам приходят:

* заголовок **X-Webhook-Secret** — «секретный ключ», чтобы убедиться, что запрос пришёл от доверенной системы;
* **event_id** — уникальный идентификатор события;
* **event_type** — тип события;
* **source** — источник события;
* **data** — полезная информация (например, `lead_id`, сумма оплаты и т. д.).

---

## Зачем нужна идемпотентность

Внешние системы могут отправлять одно и то же событие несколько раз — это нормально: из-за повторных попыток доставки, сетевых ошибок или внутренних механизмов надёжности.

Но для нас важно, чтобы это не превращалось в дубли:

* не должно появляться две «оплаты» вместо одной;
* не должны ломаться отчёты;
* не должны запускаться повторные действия «внутри процесса».

Поэтому обработка webhook должна быть **идемпотентной**:
если событие с таким `event_id` уже сохранено, мы **не сохраняем его повторно**.

---

## Передаём задачу агенту

Дальше внедряем приём внешних событий:

```
Ты senior backend-разработчик.

Необходимо реализовать webhook-контроллер для приема внешних событий оплат в EventLog из сервиса платежей.

Задачи:
- добавить в docker compose в сервис app переменную окружения WEBHOOK_SECRET
- добавить маршрут POST /api/webhook/payment: принимает запросы c заголовком X-Webhook-Secret и если он не равен env WEBHOOK_SECRET - отдает статус 401, сохраняет в EventLog значения полей (id=event_id, type=event_type=, source='payment_service', payload=data, заполняем leadId если заполнено поле data.lead_id) и отдает 200 { "status": "ok" }, если запись id=event_id уже существует отдает статус 200 { "status": "duplicate_ignored" }
- добавить команду для имитации отправки webhook оплаты через curl, где первым параметром указывается lead_id (необязательно, по умолчанию рандом), вторым параметром event_id (необязательно, по умолчанию рандом)
- проверить работоспособность команды и исправить в случае необходимости
- добавить описание запуска команды в README.md через docker compose
- добавить git коммит
- перезапустить окружение
```

---

## Проверяем, что всё работает

После того как агент внесёт изменения:

1. Находим в `README.md` команду, которая имитирует отправку webhook оплаты.
2. Запускаем её.
3. Проверяем таблицу `EventLog`.

Ожидаемый результат: в `EventLog` появляется запись с событием оплаты.

Если запустить ту же команду повторно с тем же `event_id`, новая запись появиться не должна — событие должно быть корректно «проигнорировано как дубль».
